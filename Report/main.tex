\documentclass[a4paper, 12pt]{extarticle}

% Includes 
\usepackage[utf8]{inputenc} % UTF-8 encode 
\usepackage[english, russian]{babel}
\usepackage{geometry} % adjust page layout 
\usepackage{graphicx} 
\usepackage{hyperref} 
\usepackage{amsmath} % math formulas 
\usepackage{setspace} % for set line spacing 
\usepackage{indentfirst} % indent on a first line after the paragraph 
% \usepackage{pgfplots} % for plots 
\usepackage{listings} % for code listings 
\usepackage{xcolor} % colors (used for listings)
\usepackage{sourcecodepro} % for another monospaced font 
\usepackage{cmap} % for correct search in pdf
\usepackage{placeins} % for \FloatBarrier
\usepackage{subcaption} % for subfigures


% debug
% \usepackage{showframe} % frame borders for demonstration 


%%% Custom commands
% commands for unnumbered sections
\newcommand{\usection}[1]{\section*{#1} \addcontentsline{toc}{section}{\protect\numberline{}#1}}
\newcommand{\usubsection}[1]{\subsection*{#1} \addcontentsline{toc}{subsection}{\protect\numberline{}#1}}
\newcommand{\usubsubsection}[1]{\subsubsection*{#1} \addcontentsline{toc}{subsubsection}{\protect\numberline{}#1}}


% Redefinition of section and subsection numbering style
\def\thesection{\arabic{section}.}
\def\thesubsection{\arabic{section}.\arabic{subsection}.}
\def\thesubsubsection{\arabic{section}.\arabic{subsection}.\arabic{subsubsection}.}


% Settings for links 
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}


% Layout
\geometry{
	left=17mm,
	top=17mm,
	right=17mm,
	bottom=20mm,
	marginparsep=0mm,
	marginparwidth=0mm,
	headheight=8mm,
	headsep=5mm, 
}

\linespread{1.5} % line spacing
\setlength{\parskip}{\baselineskip}  % Add space between paragraphs


% overfull hbox settings
\tolerance 10000 % default 200, max 10000
\hbadness 10000 % default 1000, max 10000
\emergencystretch 0pt  % default 0pt, how much the lines can stretch for the sake of good line breaks
\hfuzz 0.4pt % ignore overfull box less than 
\widowpenalty=10000 % no lines at the start of the page
\vfuzz \hfuzz % don't care about underfull vbox if overfull is acceptable
\raggedbottom % if the page is not filled, align the content to the bottom


% Redefinition of table of contents command to get centered heading
\makeatletter
\renewcommand\tableofcontents{ 
  \begin{singlespace}
    \null\hfill\textbf{\Large\contentsname}\hfill\null\par
    \@mkboth{\MakeUppercase\contentsname}{\MakeUppercase\contentsname}%
    \@starttoc{toc}
  \end{singlespace}
}
\makeatother


% Listings settings
\definecolor{codegreen}{rgb}{0, 0.6, 0}
\definecolor{codegray}{rgb}{0.5, 0.5, 0.5}
\definecolor{codepurple}{rgb}{0.58, 0, 0.82}
\definecolor{backcolour_gray}{rgb}{0.98, 0.98, 0.98}

\lstdefinestyle{python_white}{
  language=Python,
  backgroundcolor=\color{backcolour_gray},   
  commentstyle=\color{codegreen},
  keywordstyle=\color{blue},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codepurple},
  basicstyle=\ttfamily\small\singlespacing,
  breakatwhitespace=true,         
  breaklines=true,                 
  captionpos=b, % t/b                  
  keepspaces=true,                 
  numbers=none, % none/left/rigth                    
  numbersep=5pt,                  
  showspaces=false,                
  showstringspaces=false,
  showtabs=false,                  
  tabsize=2,
  frame=single, % none/leftline/topline/bottomline/lines/single/shadowbox
  rulecolor=\color{gray}, % frame color 
}


\lstset{style=python_white}


% For title page
\def\name{Отчет по лабораторной работе №3} 
\def\subname{Фильтрация изображений}
\def\madeby{Александр Иванов, Ф ТЕХ.ЗРЕНИЕ 1.1 \\ Ани Аракелян, ТЕХ.ЗРЕНИЕ 1.1\\ Никита Братушка, ТЕХ.ЗРЕНИЕ 1.3}
\def\teacher{Шаветов С. В.}

\begin{document}

\include{unformal_title} % Title page

\addtocounter{page}{1} % Inc counter to start from 2 
\tableofcontents % Table of contents
\pagebreak

\include{content} % Content

\clearpage
\appendix

\section{Исходный код}

\begin{lstlisting}[style=python_white]
def additive_noise(image, mean=4, sigma=0.1):
  """
  Additive noise function.

  Adds log-normal distribution noise to image

  Defined with the following expression:

  NOISY_IMAGE(x,y) = SOURCE_IMAGE(x,y) + NOISE(x,y)
  """
  rng = np.random.default_rng()
  lognormal = rng.lognormal(mean, sigma**0.5, image.shape)
  image_f = image.astype(np.float32)
  image_out = (image_f + lognormal).clip(0, 255).astype(np.uint8)
  return image_out
\end{lstlisting}

\begin{lstlisting}[style=python_white]
def noise_creation(option: int, image, mode: str = 's&p'):
  """Adds noise to image"""
  match option:
      case 1:
          # Impulse noise
          im = ski.util.random_noise(image, mode, amount=0.15)
          image_display(im, 'Impulse noise', 'Noisy_images')
      case 2:
          # Additive noise
          ad = additive_noise(image)
          image_display(ad, 'Additive noise', 'Noisy_images')
      case 3:
          # Gaussian noise
          gs = ski.util.random_noise(image, mode='gaussian', mean=0.01, var=0.1)
          image_display(gs, 'Gaussian noise', 'Noisy_images')
      case 4:
          # Speckle noise
          sp = ski.util.random_noise(image, mode='speckle', mean=0.01, var=0.1)
          image_display(sp, 'Speckle noise', 'Noisy_images')
      case 5:
          # Poisson noise
          po = ski.util.random_noise(image, mode='poisson')
          image_display(po, 'Poisson noise', 'Noisy_images')
      case _:
          # displaying source image
          image_display(image, 'Source image', 'Noisy_images')

  return 0
\end{lstlisting}

\begin{lstlisting}[style=python_white]
def contraharmonic(image, m: int, n: int, q):
  """
  Contraharmonic mean filter.

  Filter based on contraharmonic mean:

  FILTERED_IMAGE(x,y)=(SRC_IMAGE(0,0))^(q+1)+...+(SRC_IMAGE(m,n))^(q+1) / (SRC_IMAGE(0,0))^q+...+(SRC_IMAGE(m,n))^q
  """
  kernel = np.ones((m, n), dtype=np.float32)
  num = np.power(image, q+1)  # numerator
  den = np.power(image, q)    # denominator
  filtered_image = cv.filter2D(src=num, ddepth=-1, kernel=kernel) / cv.filter2D(src=den, ddepth=-1, kernel=kernel)
  return filtered_image.clip(0, 255).astype(np.uint8)
\end{lstlisting}

\begin{lstlisting}[style=python_white]
def rang_filter(src_image, k, rank):
  """Rang filtering"""
  # Filter parameters
  k_size = (k, k)
  kernel = np.ones(k_size, dtype=np.float32)
  rows, cols = src_image.shape[0:2]
  # Convert to float
  # and make image with border
  if src_image.dtype == np.uint8:
      copied_image = src_image.astype(np.float32) / 255
  else:
      copied_image = src_image
  copied_image = cv.copyMakeBorder(copied_image, int((k_size[0] - 1) / 2), int(k_size[0] / 2),
                                    int((k_size[1] - 1) / 2), int(k_size[1] / 2), cv.BORDER_REPLICATE)
  # Fill arrays for each kernel item
  I_layers = np.zeros(src_image.shape + (k_size[0] * k_size[1],), dtype=np.float32)
  if src_image.ndim == 2:
      for i in range(k_size[0]):
          for j in range(k_size[1]):
              I_layers[:, :, i * k_size[1] + j] = kernel[i, j] * copied_image[i:i + rows, j:j + cols]
  else:
      for i in range(k_size[0]):
          for j in range(k_size[1]):
              I_layers[:, :, :, i * k_size[1] + j] = kernel[i, j] * copied_image[i:i + rows, j:j + cols, :]
  # Sort arrays
  I_layers.sort()
  # Choose layer with rank
  if src_image.ndim == 2:
      filtered_image = I_layers[:, :, rank]
  else:
      filtered_image = I_layers[:, :, :, rank]

  return filtered_image
\end{lstlisting}

\begin{lstlisting}[style=python_white]
def wiener(src, k):
  """Wiener filter"""
  rows, cols = src.shape[0:2]
  # Define parameters
  k_size = (k, k)
  kernel = np.ones((k_size[0], k_size[1]))
  # Convert to float
  # and make image with border
  if src.dtype == np.uint8:
      img_copy = src.astype(np.float32) / 255
  else:
      img_copy_nb = src
  img_copy = cv.copyMakeBorder(img_copy, int((k_size[0] - 1) / 2), int(k_size[0] / 2), int((k_size[1] - 1) / 2),
                               int(k_size[1] / 2), cv.BORDER_REPLICATE)
  # Split into layers
  bgr_planes = cv.split(img_copy)
  bgr_planes_2 = []
  k_power = np.power(kernel, 2)
  for plane in bgr_planes:
      plane_power = np.power(plane, 2)
      m = np.zeros(src.shape[0:2], np.float32)
      q = np.zeros(src.shape[0:2], np.float32)
      for i in range(k_size[0]):
          for j in range(k_size[1]):
              m = m + kernel[i, j] * plane[i:i + rows, j:j + cols]
              q = q + k_power[i, j] * plane_power[i:i + rows, j:j + cols]
      m = m / np.sum(kernel)
      q = q - m * m
      v = np.sum(q) / src.size
      # Do filter
      plane_2 = plane[(k_size[0] - 1) // 2:
                      (k_size[0] - 1) // 2 + rows, (k_size[1] - 1) // 2: (k_size[1] - 1) // 2 + cols]
      plane_2 = np.where(q < v, m, (plane_2 - m) * (1 - v / q) + m)
      bgr_planes_2.append(plane_2)
  # Merge image back
  filtered_image = cv.merge(bgr_planes_2)
  if src.dtype == np.uint8:
      filtered_image = (255*filtered_image).clip(0, 255).astype(np.uint8)

  return filtered_image
\end{lstlisting}

\begin{lstlisting}[style=python_white]
def ad_median_filter(src, k, s=3):
  """Adaptive Median Filtering"""
  rows, cols = src.shape[0:2]
  img_out = np.zeros((rows, cols))
  # filling arrays for each kernel
  for r in range(rows):
      for c in range(cols):
          while s <= k:
              window = src[max(0, r - s // 2):min(rows, r + s // 2 + 1), max(0, c - s // 2):min(cols, c + s // 2 + 1)]
              mn = np.min(window)
              mx = np.max(window)
              md = np.median(window)
              if mn < md < mx:
                  if mn < src[r, c] < mx:
                      img_out[r, c] = src[r, c]
                  else:
                      img_out[r, c] = md
                  break
              else:
                  s += 2
          if s > k:
              img_out[r, c] = src[r, c]

  return img_out.astype(np.uint8)
\end{lstlisting}

\begin{lstlisting}[style=python_white]
def image_filtering(option: int, noisy_image, name: str, kx: int = 3, ky: int = 3, m=3, n=3, q=0.0, k=0, r=0):
  """Image Filtering"""
  match option:
      case 1:
          # Gaussian Blur
          gb = cv.GaussianBlur(noisy_image, (kx, ky), 0)
          image_display(gb, f'Gaussian Blur_{name}_({kx},{ky})', 'Gaussian_Blur')
      case 2:
          # Contraharmonic mean filter
          ch = contraharmonic(noisy_image, m, n, q)
          image_display(ch, f'Contraharmonic_{name}_(m,n={(m,n)},q={q})', 'Contraharmonic_Filter')
      case 3:
          # Median Filter
          md = cv.medianBlur(noisy_image, k)
          image_display(md, f'Median_{name}_(k={k})', 'Median_Filter')
      case 4:
          # 2D-Median Filter
          mdf = scipy.signal.medfilt2d(noisy_image, k)
          image_display(mdf, f'Median_2D{name}_(k={k})', 'Median_2D_Filter')
      case 5:
          # Rang Filter
          rn = rang_filter(noisy_image, k, r)*255
          image_display(rn, f'Rang_{name}_(k={k},r={r+1})', 'Rang_Filter')
      case 6:
          # Wiener Filter
          wn = wiener(noisy_image, k)
          image_display(wn, f'Wiener_{name}_(k={k})', 'Wiener_Filter')
      case 7:
          # Adaptive Median Filter
          am = ad_median_filter(noisy_image, k)
          image_display(am, f'Adaptive_Median_{name}_k={k}', 'Adaptive_Median_Filter')
      case _:
          # displaying noisy image
          image_display(noisy_image, 'Noisy_image', 'Noisy_images')
  return 0
\end{lstlisting}

\begin{lstlisting}[style=python_white]
def robertson_detection(src_image):
  g_x = np.array([[1, -1], [0, 0]])
  g_y = np.array([[1, 0], [-1, 0]])
  i_x = cv.filter2D(src_image, -1, g_x)
  i_y = cv.filter2D(src_image, -1, g_y)

  abs_grad_x = cv.convertScaleAbs(i_x)
  abs_grad_y = cv.convertScaleAbs(i_y)

  return cv.addWeighted(abs_grad_x, 0.5, abs_grad_y, 0.5, 0)
\end{lstlisting}

\begin{lstlisting}[style=python_white]
def prewitt_detection(src_image):
    g_x = np.array([[-1, 0, 1], [-1, 0, 1], [-1, 0, 1]])
    g_y = np.array([[-1, -1, -1], [0, 0, 0], [1, 1, 1]])
    i_x = cv.filter2D(src_image, -1, g_x)
    i_y = cv.filter2D(src_image, -1, g_y)

    abs_grad_x = cv.convertScaleAbs(i_x)
    abs_grad_y = cv.convertScaleAbs(i_y)

    return cv.addWeighted(abs_grad_x, 0.5, abs_grad_y, 0.5, 0)
\end{lstlisting}

\begin{lstlisting}[style=python_white]
def sobel_detection(src_image):
    i_x = cv.Sobel(src_image, cv.CV_16S, 1, 0)
    i_y = cv.Sobel(src_image, cv.CV_16S, 0, 1)

    abs_grad_x = cv.convertScaleAbs(i_x)
    abs_grad_y = cv.convertScaleAbs(i_y)

    return cv.addWeighted(abs_grad_x, 0.5, abs_grad_y, 0.5, 0)
\end{lstlisting}

\begin{lstlisting}[style=python_white]
def laplassian_detection(src_image):
    g_d = np.array([[0, -1, 0], [-1, 4, -1], [0, -1, 0]])
    return cv.filter2D(src_image, -1, g_d)
\end{lstlisting}

\begin{lstlisting}[style=python_white]
def edge_detection(option: int, noisy_image, title):
  match option:
      case 1:
          rb = robertson_detection(noisy_image)
          image_display(rb, f'Robertson_{title}', 'Edge_Detection')
      case 2:
          pr = prewitt_detection(noisy_image)
          image_display(pr, f'Prewitt_{title}', 'Edge_Detection')
      case 3:
          sb = sobel_detection(noisy_image)
          image_display(sb, f'Sobel_{title}', 'Edge_Detection')
      case 4:
          lp = laplassian_detection(noisy_image)
          image_display(lp, f'Laplassian_{title}', 'Edge_Detection')
      case 5:
          cn = cv.Canny(noisy_image, 100, 200)
          image_display(cn, f'Canny_{title}', 'Edge_Detection')
      case _:
          pass
\end{lstlisting}

\end{document}